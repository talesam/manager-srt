#!/bin/bash

# ==============================================================================
# Script: manager-srt.sh
# Description: Gerenciador avan√ßado de legendas e arquivos de m√≠dia
# Author: Narayan/Tales
# Last Update: 2024-11-25
# ==============================================================================

VERSION="1.1.5"
SCRIPT_NAME="$(basename "$0")"

# ==============================================================================
# Cores para output
# ==============================================================================

readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly MAGENTA='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly GRAY='\033[0;90m'
readonly NC='\033[0m' # No Color
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly UNDERLINE='\033[4m'

# ==============================================================================
# Vari√°veis de configura√ß√£o
# ==============================================================================

# Flags de opera√ß√£o
DRY_RUN=false
INTERACTIVE=true
VERBOSE=false
QUIET=false
CREATE_BACKUP=false
ENABLE_LOG=false
SKIP_CONFIRM=false

# Flags de opera√ß√µes espec√≠ficas
DO_RENAME_POR2=true
DO_RENAME_NO_LANG=true
DO_REMOVE_UNWANTED=true
DO_REMOVE_METADATA=true

# Configura√ß√µes
BACKUP_DIR=""
LOG_FILE=""
WORK_DIR="."
MIN_PT_WORDS=5

# Contadores
declare -i count_renamed=0
declare -i count_deleted=0
declare -i count_dirs_deleted=0
declare -i count_por2_renamed=0
declare -i count_no_lang_renamed=0
declare -i total_found_por2=0
declare -i total_found_no_lang=0
declare -i total_found_unwanted=0
declare -i total_found_metadata=0

# Arrays para preview
declare -a preview_por2_files=()
declare -a preview_no_lang_files=()
declare -a preview_unwanted_files=()
declare -a preview_metadata_dirs=()

# ==============================================================================
# Fun√ß√µes de output
# ==============================================================================

print_header() {
    if [ "$QUIET" = false ]; then
        echo -e "${BOLD}${CYAN}"
        echo "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"
        echo "‚ïë         GERENCIADOR DE LEGENDAS E ARQUIVOS DE M√çDIA v${VERSION}             ‚ïë"
        echo "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
        echo -e "${NC}"
    fi
}

print_separator() {
    if [ "$QUIET" = false ]; then
        echo -e "${BLUE}‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ${NC}"
    fi
}

print_double_separator() {
    if [ "$QUIET" = false ]; then
        echo -e "${BLUE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    fi
}

log_info() {
    [ "$QUIET" = false ] && echo -e "${CYAN}[INFO]${NC} $1"
}

log_success() {
    [ "$QUIET" = false ] && echo -e "${GREEN}[‚úì]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[‚ö†]${NC} $1"
}

log_error() {
    echo -e "${RED}[‚úó]${NC} $1" >&2
}

log_action() {
    [ "$QUIET" = false ] && echo -e "${MAGENTA}[‚Üí]${NC} $1"
}

log_debug() {
    [ "$VERBOSE" = true ] && echo -e "${GRAY}[DEBUG]${NC} $1"
}

log_dry_run() {
    echo -e "${YELLOW}[DRY-RUN]${NC} $1"
}

write_log() {
    if [ "$ENABLE_LOG" = true ] && [ -n "$LOG_FILE" ]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
    fi
}

# ==============================================================================
# Fun√ß√£o de ajuda
# ==============================================================================

show_help() {
    echo -e "$(cat << EOF
${BOLD}${CYAN}GERENCIADOR DE LEGENDAS E ARQUIVOS DE M√çDIA v${VERSION}${NC}

${BOLD}USO:${NC}
    ${SCRIPT_NAME} [OP√á√ïES]

${BOLD}DESCRI√á√ÉO:${NC}
    Script para gerenciar automaticamente legendas e arquivos de m√≠dia.
    Renomeia legendas, remove arquivos indesejados e organiza diret√≥rios.

${BOLD}OP√á√ïES GERAIS:${NC}
    ${GREEN}-h, --help${NC}              Exibe esta mensagem de ajuda
    ${GREEN}-v, --version${NC}           Exibe a vers√£o do script
    ${GREEN}-d, --dry-run${NC}           Modo preview (mostra o que ser√° feito sem executar)
    ${GREEN}-y, --yes${NC}               Pula todas as confirma√ß√µes
    ${GREEN}-i, --interactive${NC}       Modo interativo (pergunta antes de cada a√ß√£o)
    ${GREEN}-q, --quiet${NC}             Modo silencioso (m√≠nimo de output)
    ${GREEN}-V, --verbose${NC}           Modo verboso (m√°ximo de detalhes)
    ${GREEN}-w, --workdir DIR${NC}       Define diret√≥rio de trabalho (padr√£o: atual)

${BOLD}OP√á√ïES DE OPERA√á√ÉO:${NC}
    ${GREEN}--no-rename-por2${NC}        N√£o renomeia arquivos .por2.srt
    ${GREEN}--no-rename-no-lang${NC}     N√£o renomeia legendas sem idioma
    ${GREEN}--no-remove-unwanted${NC}    N√£o remove arquivos indesejados
    ${GREEN}--no-remove-metadata${NC}    N√£o remove diret√≥rios metadata
    ${GREEN}--only-rename-por2${NC}      Executa APENAS renomea√ß√£o de .por2.srt
    ${GREEN}--only-rename-no-lang${NC}   Executa APENAS renomea√ß√£o de legendas sem idioma
    ${GREEN}--only-remove-unwanted${NC}  Executa APENAS remo√ß√£o de arquivos indesejados
    ${GREEN}--only-remove-metadata${NC}  Executa APENAS remo√ß√£o de diret√≥rios metadata

${BOLD}OP√á√ïES AVAN√áADAS:${NC}
    ${GREEN}-b, --backup DIR${NC}        Cria backup antes de qualquer altera√ß√£o
    ${GREEN}-l, --log FILE${NC}          Salva log das opera√ß√µes em arquivo
    ${GREEN}--min-pt-words N${NC}        M√≠nimo de palavras PT para detec√ß√£o (padr√£o: 5)

${BOLD}OPERA√á√ïES REALIZADAS:${NC}
    ${CYAN}1.${NC} Renomeia arquivos ${YELLOW}.por2.srt${NC} para ${YELLOW}.por.srt${NC}
    ${CYAN}2.${NC} Detecta e renomeia legendas sem idioma para ${YELLOW}.por.srt${NC}
    ${CYAN}3.${NC} Remove legendas em outros idiomas (spa, eng, etc)
    ${CYAN}4.${NC} Remove imagens e arquivos NFO
    ${CYAN}5.${NC} Remove diret√≥rios 'metadata'

${BOLD}EXEMPLOS:${NC}
    ${GRAY}# Modo preview (ver o que ser√° feito)${NC}
    ${SCRIPT_NAME} --dry-run

    ${GRAY}# Executar sem confirma√ß√µes${NC}
    ${SCRIPT_NAME} --yes

    ${GRAY}# Apenas renomear .por2.srt${NC}
    ${SCRIPT_NAME} --only-rename-por2

    ${GRAY}# Criar backup e gerar log${NC}
    ${SCRIPT_NAME} --backup /tmp/backup --log /tmp/manager.log

    ${GRAY}# Modo silencioso sem confirma√ß√£o${NC}
    ${SCRIPT_NAME} --quiet --yes

    ${GRAY}# Executar em outro diret√≥rio${NC}
    ${SCRIPT_NAME} --workdir /media/filmes

${BOLD}IDIOMAS REMOVIDOS:${NC}
    ara, chi, cze, dan, dut, eng, fil, fin, fre, ger, gre, heb, hrv,
    hun, ind, ita, jpn, kor, may, nob, pol, rum, rus, spa, swe, tha,
    tur, ukr, vie, hin, nor, tam, tel, slo, bul, lav, lit, slv, glg,
    cat, baq

${BOLD}ARQUIVOS REMOVIDOS:${NC}
    Legendas em outros idiomas, imagens (jpg, png, gif), arquivos NFO

${BOLD}DETEC√á√ÉO DE PORTUGU√äS:${NC}
    O script analisa as primeiras 100 linhas da legenda procurando por
    palavras comuns em portugu√™s. Se encontrar pelo menos ${MIN_PT_WORDS} palavras,
    considera o arquivo como portugu√™s.

${BOLD}AUTOR:${NC}
    Narayan/Tales

${BOLD}REPOSIT√ìRIO:${NC}
    https://github.com/seu-usuario/manager-srt

EOF
)"
}

show_version() {
    echo -e "${BOLD}${CYAN}manager-srt${NC} vers√£o ${GREEN}${VERSION}${NC}"
    echo "Copyright (C) 2025 Narayan/Tales"
    echo "Licen√ßa: MIT"
}

# ==============================================================================
# Fun√ß√£o para detectar se um arquivo SRT √© portugu√™s
# ==============================================================================

is_portuguese_subtitle() {
    local file="$1"
    
    # Palavras comuns em portugu√™s para detec√ß√£o
    local pt_words=("que" "n√£o" "para" "com" "uma" "mais" "muito" "est√°" "voc√™" "seu" "sua" "ele" "ela" "s√£o" "mas" "por" "at√©" "tamb√©m" "bem" "foi" "ser" "vai" "pode" "ainda" "onde" "quando" "como" "porque" "sem" "sobre" "est√°" "todo" "tinha" "foram" "fazer")
    
    # L√™ as primeiras 100 linhas do arquivo
    local content=$(head -n 100 "$file" 2>/dev/null | tr '[:upper:]' '[:lower:]')
    
    if [ -z "$content" ]; then
        log_debug "Arquivo vazio ou ileg√≠vel: $file"
        return 1
    fi
    
    # Conta quantas palavras portuguesas foram encontradas
    local matches=0
    for word in "${pt_words[@]}"; do
        if echo "$content" | grep -qw "$word"; then
            ((matches++))
        fi
        
        # Se encontrar o m√≠nimo de palavras portuguesas, considera como portugu√™s
        if [ $matches -ge $MIN_PT_WORDS ]; then
            log_debug "Detectadas $matches palavras PT em: $(basename "$file")"
            return 0
        fi
    done
    
    log_debug "Apenas $matches palavras PT encontradas em: $(basename "$file")"
    return 1
}

# ==============================================================================
# Fun√ß√£o para criar backup
# ==============================================================================

create_backup() {
    if [ "$CREATE_BACKUP" = true ] && [ -n "$BACKUP_DIR" ]; then
        log_info "Criando backup em: ${YELLOW}${BACKUP_DIR}${NC}"
        
        local timestamp=$(date +%Y%m%d_%H%M%S)
        local backup_path="${BACKUP_DIR}/backup_${timestamp}"
        
        mkdir -p "$backup_path" || {
            log_error "Falha ao criar diret√≥rio de backup!"
            return 1
        }
        
        # Copia arquivos que ser√£o modificados/removidos
        fd -u -t f -e srt -e jpg -e png -e nfo . "$WORK_DIR" \
            -x cp --parents {} "$backup_path" 2>/dev/null
        
        log_success "Backup criado em: ${GREEN}${backup_path}${NC}"
        write_log "Backup criado em: ${backup_path}"
        return 0
    fi
    return 0
}

# ==============================================================================
# Fun√ß√£o para escanear e coletar informa√ß√µes (preview)
# ==============================================================================

scan_files() {
    log_info "Escaneando diret√≥rio: ${YELLOW}${WORK_DIR}${NC}"
    print_separator
    
    # Escanear arquivos .por2.srt
    if [ "$DO_RENAME_POR2" = true ]; then
        log_info "üîç Procurando arquivos ${YELLOW}.por2.srt${NC}..."
        while IFS= read -r -d '' file; do
            preview_por2_files+=("$file")
            ((total_found_por2++))
        done < <(fd -u -t f -g "*.por2.srt" "$WORK_DIR" -0)
        
        if [ $total_found_por2 -gt 0 ]; then
            echo -e "   ${GREEN}‚úì${NC} Encontrados: ${BOLD}${total_found_por2}${NC} arquivos"
        else
            echo -e "   ${GRAY}‚óã${NC} Nenhum arquivo encontrado"
        fi
    fi
    
    # Escanear legendas sem idioma
    if [ "$DO_RENAME_NO_LANG" = true ]; then
        log_info "üîç Procurando legendas sem idioma..."
        while IFS= read -r -d '' file; do
            local basename=$(basename "$file")
            
            # Pular arquivos .por2.srt (ser√£o processados separadamente)
            if [[ "$basename" =~ \.por2\.srt$ ]]; then
                continue
            fi
            
            # Verifica se j√° tem c√≥digo de idioma
            if [[ "$basename" =~ \.[a-z]{3}\.srt$ ]] || [[ "$basename" =~ \.[a-z]{3}[0-9]\.srt$ ]]; then
                continue
            fi
            
            # Verifica se termina com .srt e n√£o tem idioma
            if [[ "$basename" =~ \.srt$ ]] && ! [[ "$basename" =~ \.[a-z]{3}\.srt$ ]]; then
                if is_portuguese_subtitle "$file"; then
                    preview_no_lang_files+=("$file")
                    ((total_found_no_lang++))
                fi
            fi
        done < <(fd -u -t f -g "*.srt" -E "*.forced.srt" "$WORK_DIR" -0)
        
        if [ $total_found_no_lang -gt 0 ]; then
            echo -e "   ${GREEN}‚úì${NC} Encontrados: ${BOLD}${total_found_no_lang}${NC} arquivos"
        else
            echo -e "   ${GRAY}‚óã${NC} Nenhum arquivo encontrado"
        fi
    fi
    
    # Escanear arquivos indesejados
    if [ "$DO_REMOVE_UNWANTED" = true ]; then
        log_info "üîç Procurando arquivos indesejados..."
        
        # Array associativo para evitar duplicatas
        declare -A seen_files
        
        local patterns=(
            # Legendas em outros idiomas (captura .eng.srt, .eng2.srt, .eng.forced.srt, etc.)
            "*.ara*.srt" "*.chi*.srt" "*.cze*.srt" "*.dan*.srt" "*.dut*.srt"
            "*.eng*.srt" "*.fil*.srt" "*.fin*.srt" "*.fre*.srt" "*.ger*.srt"
            "*.gre*.srt" "*.heb*.srt" "*.hrv*.srt" "*.hun*.srt" "*.ind*.srt"
            "*.ita*.srt" "*.jpn*.srt" "*.kor*.srt" "*.may*.srt" "*.nob*.srt"
            "*.pol*.srt" "*.rum*.srt" "*.rus*.srt" "*.spa*.srt" "*.swe*.srt"
            "*.tha*.srt" "*.tur*.srt" "*.ukr*.srt" "*.vie*.srt" "*.hin*.srt"
            "*.nor*.srt" "*.tam*.srt" "*.tel*.srt" "*.slo*.srt" "*.bul*.srt"
            "*.lav*.srt" "*.lit*.srt" "*.slv*.srt" "*.glg*.srt" "*.cat*.srt"
            "*.baq*.srt"
            # Arquivos de imagem e metadados
            "*.jpg" "*.jpeg" "*.png" "*.gif" "*.bmp" "*.nfo"
        )
        
        for pattern in "${patterns[@]}"; do
            while IFS= read -r -d '' file; do
                # Evita duplicatas
                if [ -z "${seen_files[$file]}" ]; then
                    preview_unwanted_files+=("$file")
                    seen_files[$file]=1
                    ((total_found_unwanted++))
                fi
            done < <(fd -u -t f -g "$pattern" "$WORK_DIR" -0)
        done
        
        if [ $total_found_unwanted -gt 0 ]; then
            echo -e "   ${GREEN}‚úì${NC} Encontrados: ${BOLD}${total_found_unwanted}${NC} arquivos"
        else
            echo -e "   ${GRAY}‚óã${NC} Nenhum arquivo encontrado"
        fi
    fi
    
    # Escanear diret√≥rios metadata
    if [ "$DO_REMOVE_METADATA" = true ]; then
        log_info "üîç Procurando diret√≥rios 'metadata'..."
        while IFS= read -r -d '' dir; do
            preview_metadata_dirs+=("$dir")
            ((total_found_metadata++))
        done < <(fd -u -t d -g "metadata" "$WORK_DIR" -0)
        
        if [ $total_found_metadata -gt 0 ]; then
            echo -e "   ${GREEN}‚úì${NC} Encontrados: ${BOLD}${total_found_metadata}${NC} diret√≥rios"
        else
            echo -e "   ${GRAY}‚óã${NC} Nenhum diret√≥rio encontrado"
        fi
    fi
    
    print_separator
}

# ==============================================================================
# Fun√ß√£o para exibir preview detalhado
# ==============================================================================

show_preview() {
    echo ""
    print_double_separator
    echo -e "${BOLD}${YELLOW}üìã PREVIEW DAS OPERA√á√ïES${NC}"
    print_double_separator
    echo ""
    
    local total_operations=$((total_found_por2 + total_found_no_lang + total_found_unwanted + total_found_metadata))
    
    if [ $total_operations -eq 0 ]; then
        echo -e "${GREEN}‚úì Nenhuma opera√ß√£o necess√°ria. Tudo est√° organizado!${NC}"
        echo ""
        return 0
    fi
    
    # Preview: Renomear .por2.srt
    if [ ${#preview_por2_files[@]} -gt 0 ]; then
        echo -e "${BOLD}${CYAN}1. Renomear arquivos .por2.srt ‚Üí .por.srt${NC} (${total_found_por2} arquivos)"
        echo ""
        
        local count=0
        for file in "${preview_por2_files[@]}"; do
            local newname="${file%.por2.srt}.por.srt"
            echo -e "   ${MAGENTA}‚Üí${NC} ${DIM}$(basename "$file")${NC}"
            echo -e "      ${GREEN}‚Üí $(basename "$newname")${NC}"
            
            ((count++))
            if [ $count -ge 5 ] && [ ${#preview_por2_files[@]} -gt 5 ]; then
                local remaining=$((${#preview_por2_files[@]} - count))
                echo -e "   ${GRAY}... e mais ${remaining} arquivos${NC}"
                break
            fi
        done
        echo ""
    fi
    
    # Preview: Renomear sem idioma
    if [ ${#preview_no_lang_files[@]} -gt 0 ]; then
        echo -e "${BOLD}${CYAN}2. Adicionar .por.srt a legendas sem idioma${NC} (${total_found_no_lang} arquivos)"
        echo ""
        
        local count=0
        for file in "${preview_no_lang_files[@]}"; do
            local basename=$(basename "$file")
            local newname="${basename%.srt}.por.srt"
            echo -e "   ${MAGENTA}‚Üí${NC} ${DIM}$basename${NC}"
            echo -e "      ${GREEN}‚Üí $newname${NC}"
            
            ((count++))
            if [ $count -ge 5 ] && [ ${#preview_no_lang_files[@]} -gt 5 ]; then
                local remaining=$((${#preview_no_lang_files[@]} - count))
                echo -e "   ${GRAY}... e mais ${remaining} arquivos${NC}"
                break
            fi
        done
        echo ""
    fi
    
    # Preview: Remover indesejados
    if [ ${#preview_unwanted_files[@]} -gt 0 ]; then
        echo -e "${BOLD}${CYAN}3. Remover arquivos indesejados${NC} (${total_found_unwanted} arquivos)"
        echo ""
        
        # Agrupa por tipo
        declare -A file_types
        for file in "${preview_unwanted_files[@]}"; do
            local ext="${file##*.}"
            file_types[$ext]=$((${file_types[$ext]:-0} + 1))
        done
        
        for ext in "${!file_types[@]}"; do
            echo -e "   ${RED}‚úó${NC} ${file_types[$ext]} arquivo(s) ${YELLOW}.${ext}${NC}"
        done
        
        if [ "$VERBOSE" = true ]; then
            echo ""
            local count=0
            for file in "${preview_unwanted_files[@]}"; do
                echo -e "   ${RED}‚úó${NC} ${DIM}$(basename "$file")${NC}"
                ((count++))
                [ $count -ge 10 ] && break
            done
            if [ ${#preview_unwanted_files[@]} -gt 10 ]; then
                local remaining=$((${#preview_unwanted_files[@]} - 10))
                echo -e "   ${GRAY}... e mais ${remaining} arquivos${NC}"
            fi
        fi
        echo ""
    fi
    
    # Preview: Remover metadata
    if [ ${#preview_metadata_dirs[@]} -gt 0 ]; then
        echo -e "${BOLD}${CYAN}4. Remover diret√≥rios 'metadata'${NC} (${total_found_metadata} diret√≥rios)"
        echo ""
        
        local count=0
        for dir in "${preview_metadata_dirs[@]}"; do
            echo -e "   ${RED}‚úó${NC} ${DIM}${dir}${NC}"
            
            ((count++))
            if [ $count -ge 5 ] && [ ${#preview_metadata_dirs[@]} -gt 5 ]; then
                local remaining=$((${#preview_metadata_dirs[@]} - count))
                echo -e "   ${GRAY}... e mais ${remaining} diret√≥rios${NC}"
                break
            fi
        done
        echo ""
    fi
    
    print_double_separator
    echo -e "${BOLD}${WHITE}üìä RESUMO:${NC}"
    echo ""
    echo -e "  ${CYAN}Arquivos .por2.srt a renomear:${NC}      ${BOLD}${total_found_por2}${NC}"
    echo -e "  ${CYAN}Legendas sem idioma a renomear:${NC}     ${BOLD}${total_found_no_lang}${NC}"
    echo -e "  ${CYAN}Arquivos a remover:${NC}                 ${BOLD}${total_found_unwanted}${NC}"
    echo -e "  ${CYAN}Diret√≥rios a remover:${NC}               ${BOLD}${total_found_metadata}${NC}"
    echo -e "  ${WHITE}‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ${NC}"
    echo -e "  ${BOLD}${GREEN}Total de opera√ß√µes:${NC}                 ${BOLD}${total_operations}${NC}"
    echo ""
    print_double_separator
}

# ==============================================================================
# Fun√ß√£o para renomear .por2.srt para .por.srt
# ==============================================================================

rename_por2_to_por() {
    if [ "$DO_RENAME_POR2" = false ]; then
        return 0
    fi
    
    log_info "Renomeando arquivos ${YELLOW}.por2.srt${NC}..."
    
    for file in "${preview_por2_files[@]}"; do
        local newname="${file%.por2.srt}.por.srt"
        
        if [ -f "$newname" ]; then
            log_warning "Arquivo ${YELLOW}$(basename "$newname")${NC} j√° existe. Pulando..."
            write_log "SKIP: $(basename "$file") - destino j√° existe"
        else
            if [ "$DRY_RUN" = true ]; then
                log_dry_run "Renomearia: $(basename "$file") ‚Üí $(basename "$newname")"
            else
                mv "$file" "$newname" && {
                    log_success "Renomeado: ${GREEN}$(basename "$newname")${NC}"
                    write_log "RENAMED: $(basename "$file") ‚Üí $(basename "$newname")"
                    ((++count_por2_renamed))
                } || {
                    log_error "Falha ao renomear: $(basename "$file")"
                    write_log "ERROR: Failed to rename $(basename "$file")"
                }
            fi
        fi
    done
    
    if [ $count_por2_renamed -eq 0 ] && [ "$DRY_RUN" = false ]; then
        log_info "Nenhum arquivo .por2.srt foi renomeado."
    fi
}

# ==============================================================================
# Fun√ß√£o para renomear legendas sem idioma
# ==============================================================================

rename_no_language_subtitles() {
    if [ "$DO_RENAME_NO_LANG" = false ]; then
        return 0
    fi
    
    log_info "Renomeando legendas sem identifica√ß√£o de idioma..."
    
    for file in "${preview_no_lang_files[@]}"; do
        local basename=$(basename "$file")
        local dirname=$(dirname "$file")
        local newname="${basename%.srt}.por.srt"
        local fullnewpath="$dirname/$newname"
        
        if [ -f "$fullnewpath" ]; then
            log_warning "Arquivo ${YELLOW}$newname${NC} j√° existe. Pulando..."
            write_log "SKIP: $basename - destino j√° existe"
        else
            if [ "$DRY_RUN" = true ]; then
                log_dry_run "Renomearia: $basename ‚Üí $newname"
            else
                mv "$file" "$fullnewpath" && {
                    log_success "Detectado PT e renomeado: ${GREEN}$newname${NC}"
                    write_log "RENAMED: $basename ‚Üí $newname"
                    ((++count_no_lang_renamed))
                } || {
                    log_error "Falha ao renomear: $basename"
                    write_log "ERROR: Failed to rename $basename"
                }
            fi
        fi
    done
    
    if [ $count_no_lang_renamed -eq 0 ] && [ "$DRY_RUN" = false ]; then
        log_info "Nenhuma legenda sem idioma foi renomeada."
    fi
}

# ==============================================================================
# Fun√ß√£o para remover arquivos indesejados
# ==============================================================================

remove_unwanted_files() {
    if [ "$DO_REMOVE_UNWANTED" = false ]; then
        return 0
    fi
    
    log_info "Removendo arquivos indesejados..."
    
    for file in "${preview_unwanted_files[@]}"; do
        if [ "$DRY_RUN" = true ]; then
            log_dry_run "Removeria: $(basename "$file")"
        else
            rm "$file" && {
                log_action "Removido: ${RED}$(basename "$file")${NC}"
                write_log "DELETED: $(basename "$file")"
                ((++count_deleted))
            } || {
                log_error "Falha ao remover: $(basename "$file")"
                write_log "ERROR: Failed to delete $(basename "$file")"
            }
        fi
    done
    
    if [ $count_deleted -eq 0 ] && [ "$DRY_RUN" = false ]; then
        log_info "Nenhum arquivo indesejado foi removido."
    fi
}

# ==============================================================================
# Fun√ß√£o para remover diret√≥rios metadata
# ==============================================================================

remove_metadata_dirs() {
    if [ "$DO_REMOVE_METADATA" = false ]; then
        return 0
    fi
    
    log_info "Removendo diret√≥rios 'metadata'..."
    
    for dir in "${preview_metadata_dirs[@]}"; do
        if [ "$DRY_RUN" = true ]; then
            log_dry_run "Removeria: $dir"
        else
            rm -rf "$dir" && {
                log_action "Diret√≥rio removido: ${RED}$dir${NC}"
                write_log "DELETED DIR: $dir"
                ((++count_dirs_deleted))
            } || {
                log_error "Falha ao remover: $dir"
                write_log "ERROR: Failed to delete dir $dir"
            }
        fi
    done
    
    if [ $count_dirs_deleted -eq 0 ] && [ "$DRY_RUN" = false ]; then
        log_info "Nenhum diret√≥rio 'metadata' foi removido."
    fi
}

# ==============================================================================
# Fun√ß√£o para exibir resumo final
# ==============================================================================

print_summary() {
    print_separator
    echo -e "${BOLD}${WHITE}üìä RESUMO DA OPERA√á√ÉO:${NC}"
    echo ""
    
    if [ "$DRY_RUN" = true ]; then
        echo -e "  ${YELLOW}‚ö† MODO DRY-RUN - Nenhuma altera√ß√£o foi feita${NC}"
        echo ""
    fi
    
    echo -e "  ${CYAN}Arquivos .por2.srt renomeados:${NC}     ${BOLD}$count_por2_renamed${NC}"
    echo -e "  ${CYAN}Legendas sem idioma renomeadas:${NC}    ${BOLD}$count_no_lang_renamed${NC}"
    echo -e "  ${CYAN}Arquivos removidos:${NC}                ${BOLD}$count_deleted${NC}"
    echo -e "  ${CYAN}Diret√≥rios removidos:${NC}              ${BOLD}$count_dirs_deleted${NC}"
    echo ""
    
    local total=$((count_por2_renamed + count_no_lang_renamed + count_deleted + count_dirs_deleted))
    
    if [ $total -eq 0 ]; then
        if [ "$DRY_RUN" = false ]; then
            echo -e "  ${GREEN}‚úì Nenhuma a√ß√£o foi necess√°ria. Tudo est√° organizado!${NC}"
        else
            echo -e "  ${YELLOW}‚úì Nenhuma a√ß√£o seria necess√°ria.${NC}"
        fi
    else
        if [ "$DRY_RUN" = false ]; then
            echo -e "  ${GREEN}‚úì Total de opera√ß√µes realizadas: ${BOLD}$total${NC}"
        else
            echo -e "  ${YELLOW}‚úì Total de opera√ß√µes que seriam realizadas: ${BOLD}$total${NC}"
        fi
    fi
    
    echo ""
    print_separator
}

# ==============================================================================
# Fun√ß√£o de confirma√ß√£o
# ==============================================================================

confirm_execution() {
    if [ "$SKIP_CONFIRM" = true ]; then
        return 0
    fi
    
    echo ""
    local total_operations=$((total_found_por2 + total_found_no_lang + total_found_unwanted + total_found_metadata))
    
    if [ $total_operations -eq 0 ]; then
        return 1
    fi
    
    if [ "$INTERACTIVE" = true ]; then
        echo -e -n "${BOLD}${YELLOW}Deseja executar estas opera√ß√µes? [s/N]: ${NC}"
        read -n 1 -r
        echo ""
        
        if [[ ! $REPLY =~ ^[SsYy]$ ]]; then
            log_warning "Opera√ß√£o cancelada pelo usu√°rio."
            return 1
        fi
    fi
    
    return 0
}

# ==============================================================================
# Processamento de argumentos
# ==============================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -d|--dry-run)
                DRY_RUN=true
                SKIP_CONFIRM=true
                shift
                ;;
            -y|--yes)
                SKIP_CONFIRM=true
                INTERACTIVE=false
                shift
                ;;
            -i|--interactive)
                INTERACTIVE=true
                shift
                ;;
            -q|--quiet)
                QUIET=true
                shift
                ;;
            -V|--verbose)
                VERBOSE=true
                shift
                ;;
            -w|--workdir)
                WORK_DIR="$2"
                shift 2
                ;;
            -b|--backup)
                CREATE_BACKUP=true
                BACKUP_DIR="$2"
                shift 2
                ;;
            -l|--log)
                ENABLE_LOG=true
                LOG_FILE="$2"
                shift 2
                ;;
            --min-pt-words)
                MIN_PT_WORDS="$2"
                shift 2
                ;;
            --no-rename-por2)
                DO_RENAME_POR2=false
                shift
                ;;
            --no-rename-no-lang)
                DO_RENAME_NO_LANG=false
                shift
                ;;
            --no-remove-unwanted)
                DO_REMOVE_UNWANTED=false
                shift
                ;;
            --no-remove-metadata)
                DO_REMOVE_METADATA=false
                shift
                ;;
            --only-rename-por2)
                DO_RENAME_POR2=true
                DO_RENAME_NO_LANG=false
                DO_REMOVE_UNWANTED=false
                DO_REMOVE_METADATA=false
                shift
                ;;
            --only-rename-no-lang)
                DO_RENAME_POR2=false
                DO_RENAME_NO_LANG=true
                DO_REMOVE_UNWANTED=false
                DO_REMOVE_METADATA=false
                shift
                ;;
            --only-remove-unwanted)
                DO_RENAME_POR2=false
                DO_RENAME_NO_LANG=false
                DO_REMOVE_UNWANTED=true
                DO_REMOVE_METADATA=false
                shift
                ;;
            --only-remove-metadata)
                DO_RENAME_POR2=false
                DO_RENAME_NO_LANG=false
                DO_REMOVE_UNWANTED=false
                DO_REMOVE_METADATA=true
                shift
                ;;
            *)
                log_error "Op√ß√£o desconhecida: $1"
                echo "Use --help para ver as op√ß√µes dispon√≠veis."
                exit 1
                ;;
        esac
    done
}

# ==============================================================================
# Fun√ß√£o principal
# ==============================================================================

main() {
    # Parse argumentos
    parse_arguments "$@"
    
    # Exibe header
    print_header
    
    # Valida diret√≥rio de trabalho
    if [ ! -d "$WORK_DIR" ]; then
        log_error "Diret√≥rio n√£o existe: ${WORK_DIR}"
        exit 1
    fi
    
    # Converte para caminho absoluto
    WORK_DIR=$(cd "$WORK_DIR" && pwd)
    
    log_info "Diret√≥rio de trabalho: ${YELLOW}${WORK_DIR}${NC}"
    
    if [ "$DRY_RUN" = true ]; then
        log_warning "MODO DRY-RUN ATIVADO - Nenhuma altera√ß√£o ser√° feita"
    fi
    
    echo ""
    
    # Cria backup se necess√°rio
    if [ "$CREATE_BACKUP" = true ]; then
        create_backup || {
            log_error "Falha ao criar backup. Abortando."
            exit 1
        }
        echo ""
    fi
    
    # Inicializa log
    if [ "$ENABLE_LOG" = true ]; then
        write_log "=== IN√çCIO DA OPERA√á√ÉO ==="
        write_log "Diret√≥rio: $WORK_DIR"
        write_log "Modo dry-run: $DRY_RUN"
    fi
    
    # Escaneia arquivos
    scan_files
    
    # Exibe preview
    show_preview
    
    # Confirma execu√ß√£o
    if ! confirm_execution; then
        exit 0
    fi
    
    # Se n√£o for dry-run, executa as opera√ß√µes
    if [ "$DRY_RUN" = false ]; then
        echo ""
        print_double_separator
        echo -e "${BOLD}${GREEN}üöÄ EXECUTANDO OPERA√á√ïES${NC}"
        print_double_separator
        echo ""
        
        rename_por2_to_por
        echo ""
        
        rename_no_language_subtitles
        echo ""
        
        remove_unwanted_files
        echo ""
        
        remove_metadata_dirs
        echo ""
    fi
    
    # Exibe resumo
    print_summary
    
    if [ "$DRY_RUN" = false ]; then
        log_success "Opera√ß√£o conclu√≠da com sucesso!"
    else
        log_info "Preview conclu√≠do. Use sem --dry-run para executar."
    fi
    
    # Finaliza log
    if [ "$ENABLE_LOG" = true ]; then
        write_log "=== FIM DA OPERA√á√ÉO ==="
    fi
}

# ==============================================================================
# Execu√ß√£o
# ==============================================================================

main "$@"
